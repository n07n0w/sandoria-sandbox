<html>
<head>

<%
	var categoryImagesPerRow = 3;
	var categoryImageWidth  = 100;
	var categoryImageHeight = 130;
	var categoryImageSpacing = 24;	// расстояние между картинками категорий
	var maxImageWidth  = 100;
	var maxImageHeight = 130;
	var sandboxBorderTopHeight = 35;
	var sandboxBorderBottomHeight = 35;
	var sandboxBorderLeftWidth = 30;
	var sandboxBorderRightWidth = 40;
	var clientMode = (typeof sessionId !== 'undefined' && typeof opponentSessionId !== 'undefined');
	var viewMode = (typeof sessionId !== 'undefined' && typeof opponentSessionId === 'undefined');
	var iterationHolderSandboxWidthPercent = 75;

	// интервал, по истечении которого сессия психолог-клиент ватоматически разрівается (в миллисекундах)
	var sessionConnectionTimeout = (locals.sessionConnectionTimeout) ? locals.sessionConnectionTimeout : 3600000; // по умолчанию - 1 час (3600 секунд * 1000 = 3600000 миллисекунд)
%>

<%/*
<link rel="stylesheet" href="https://code.jquery.com/ui/1.14.1/themes/base/jquery-ui.css">
*/%>
<link rel="stylesheet" href="/stylesheets/jquery-ui.css">
<link rel="stylesheet" href="/stylesheets/jquery.slidein.css">
<link rel="stylesheet" href="/stylesheets/sandbox.css">
<link rel="stylesheet" href="/stylesheets/mobile.css">


  <script src="/javascripts/jquery-3.7.1.js"></script>
  <script src="/javascripts/jquery-ui.js"></script>
  <!-- https://konvajs.org/docs/index.html -->
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
<%/*
  <script src="/javascripts/konva.min.js"></script>
*/%>



<style>
.ui-dialog-titlebar {
	display: none;
}

.invitepbсsmall {
	color: #CE8164;
	font-size: 18px;
	line-height: 120%;
	margin: 0;
}
#progress {
	position: fixed;
	top: 0;
	left: 0;
	width: 100vw;
	height: 100vh;
	background-color: rgba(0, 0, 0, 0.7); /* напівпрозорий чорний фон */
	color: white;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 2em;
	z-index: 9999; /* поверх усього */
	font-family: sans-serif;
	pointer-events: none; /* щоб не заважало клікам (опційно) */
}

</style>

	<% if (typeof sessionId !== 'undefined' && typeof opponentSessionId === 'undefined') { %>
	<script src="/javascripts/jquery.slidein.js"></script>
	<% } %>


<%/*
	<script src="/javascripts/p2pConnectionGlobal.js"></script>
*/%>
	<script src="/javascripts/p2pConnectionGlobalPromise.js"></script>
	
  <script type="text/javascript">
//      const leftSideWidth = 208;	// ширина левой части не мняется!
	  var eventHistory = [];
      var sandboxBackground = "";
      var width = window.innerWidth;
      var height = window.innerHeight;
      var sandboxLayer, backgroundLayer;
	  var backgroundImage;
      var background;
      var transformer;
      var prevCategoryId;
      var myPeer;
      var myConn;
	  var stage;
	  var invitePopupDialog;
	  var categoryImageMaxPanelWidth = 0;
	  var categoryImageMinPanelWidth = 0;
	  var iterationHolderSandboxWidthPercent = <%=iterationHolderSandboxWidthPercent %>;
	  var sandboxBorderTopHeight = <%=sandboxBorderTopHeight %>;
	  var sandboxBorderBottomHeight = <%=sandboxBorderBottomHeight %>;
	  var sandboxBorderLeftWidth = <%=sandboxBorderLeftWidth %>;
	  var sandboxBorderRightWidth = <%=sandboxBorderRightWidth %>;
	  var sessionConnectionTimeout = <%=sessionConnectionTimeout %>;
	  var clientMode = <%=clientMode %>;
	  var firstCategorySelected = false;
	  var canDoctorEditImages = true;
	  const ratio = 8;


	  var maxImageWidth  = <%=maxImageWidth %>;
	  var maxImageHeight = <%=maxImageHeight %>;
	  var categoryImagesPerRow = <%=categoryImagesPerRow %>;
		var categoryImageWidth  = <%=categoryImageWidth %>;
		var categoryImageHeight = <%=categoryImageHeight %>;
		var categoryImageSpacing = <%=categoryImageSpacing %>;
	  var ws;
	  <% if (typeof sessionId !== 'undefined') { %>
	  var sessionId = '<%= sessionId%>';
      <% } else { %>
	  var sessionId = null;
      <% } %>

	  <% if (typeof sessionId !== 'undefined' && typeof opponentSessionId !== 'undefined') { %>
	  console.log("notifyViewer set to true");
	  var notifyViewer = true;
	  var guest = true;
      <% } else { %>
	  console.log("notifyViewer set to false");
	  var notifyViewer = false;
	  var guest = false;
      <% } %>

	const sleep = (ms) => {
		return new Promise(resolve => setTimeout(resolve, ms));
	};

	const preProcessEvent = (ev) => {
		if (!(ev.skipFromHistory || false) && !(ev.fromHistory || false)) {
			if (0 > eventHistory.length && ev.historyCmpFn && ev.historyCmpFn(ev, eventHistory[eventHistory.length - 1])) {
				eventHistory[eventHistory.length - 1] = ev;
			} else {
				eventHistory.push(ev);
			}
			saveKonvaState();
		}
		delete ev.skipFromHistory;
		delete ev.fromHistory;
		delete ev.historyCmpFn;
		return ev;
	};

	const sendEvent = function (ev) {
		ev = preProcessEvent(ev);
		myConn?.send(ev);
	};

	const notifyImageSelect = (jsonData) => {
//		saveKonvaState();
		sendEvent(jsonData);
	};

    const notifyShapeClick = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyShapeDrag = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyMeDrag = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyTransform = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyRemoveSelected = function (jsonData) {
      sendEvent(jsonData);
    };
    const notifyRemoveAll = function (jsonData) {
      sendEvent(jsonData);
    };
    const notifyCopySelected = function (jsonData) {
      sendEvent(jsonData);
    };
    const notifySkewSelected = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyLevelUp = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifyLevelDown = function (jsonData) {
      sendEvent(jsonData);
    };

    const notifySaveStateToImage = function (jsonData) {
      sendEvent(jsonData);
    };

	const notifySaveStateToImageResponse = function (jsonData) {
      sendEvent(jsonData);
    };

    const imageSelectEvent = function(imgSource, categoryId, imageId) {
      var jsonData = {};
      jsonData['event']      = 'imageSelect';
      jsonData['imgSource']  = imgSource;
      jsonData['categoryId'] = categoryId;
	  jsonData['imageId']    = imageId;
	  jsonData['uuid']       = crypto.randomUUID();
      jsonData['notify']     = false;
      return jsonData;
    };

    const restoreStateEvent = function(stageJson) {
      var jsonData = {};
      jsonData['event']  = 'restoreState';
	  jsonData['stage']  = stageJson;
      jsonData['notify'] = false;
	  jsonData['skipFromHistory']  = true;
      return jsonData;
    };

	const restoreState = function (jsonObject, notify = false) {
		stageFromJson(jsonObject.stage);
//		loadKonvaState();
	}

    const positionedImageSelectEvent = function(imgSource, categoryId, imageId, x, y) {
      var jsonData = {};
      jsonData['event']      = 'positionedImageSelect';
      jsonData['imgSource']  = imgSource;
      jsonData['categoryId'] = categoryId;
	  jsonData['imageId']    = imageId;
	  jsonData['x']          = x;
	  jsonData['y']          = y;
      jsonData['notify']     = false;
      return jsonData;
    };

	const handleImageSelect = function(jsonObject, notify = false) {
		if (clientMode || canDoctorEditImages) {
			imageSelect(jsonObject, notify);
		}
	}

	const imageSelect = function (jsonObject, notify = false) {
		let img = document.querySelector(`img.category_image[imgid='${jsonObject.imageId}']`);
		let stageMiddleX = stage.width() >> 1;
		let stageMiddleY = stage.height() >> 1;
		let newImageX = stageMiddleX - (img.offsetWidth >> 1);
		let newImageY = stageMiddleY - (img.offsetHeight >> 1);

		animateImageMoveToCanvasCenter(img, newImageX, newImageY);
		if ( categoryImageMaxPanelWidth == $("#categoryImages").width() ) {
//			requestAnimationFrame((timestamp) => animateBackground(timestamp, $("#categoryImages")[0], 1));
			animateElementBackgroundOpacity($("#categoryImages")[0]);
		}

		setTimeout(() => {
			loadImage(jsonObject.imgSource, jsonObject.categoryId, jsonObject.imageId, jsonObject.uuid);
		}, 1100);
//		loadImage(jsonObject.imgSource, jsonObject.categoryId, jsonObject.imageId);
		if (notify) {
			notifyImageSelect(jsonObject);
		}
	};


    const positionedImageSelect = function (jsonObject, notify = false) {
	  loadPositionedImage(jsonObject.imgSource, jsonObject.categoryId, jsonObject.imageId, jsonObject.x, jsonObject.y);
	  if (notify) {
	    notifyImageSelect(jsonObject);
	  }
	};

	const shapeClick = function(jsonData) {
		var node = sandboxLayer.findOne(node => {
//        return node.getType() === 'Shape' && node._id == jsonData.shape._id;
////			return node.getType() === 'Shape' && node.getAttr('imgId') == jsonData.shape.img_id;
			return node.getType() === 'Shape' && node.getAttr('uuid') == jsonData.shape.uuid;
		});
//      node.fire('click');
		if (node)
			transformer.nodes([node]);
	};

    const shapeClickEvent = function (shape) {
      var jsonData = {};
      jsonData['event']  = 'shapeClick';
      var shapeObject = {};
      shapeObject['_id'] = shape._id;
      shapeObject['img_id'] = shape.getAttr('imgId');
      shapeObject['uuid'] = shape.getAttr('uuid');
      jsonData['shape']  = shapeObject;
      jsonData['notify'] = false;
      return jsonData;
    };

    const disconnectEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'disconnectPeer';
      jsonData['skipFromHistory']  = true;
      jsonData['notify'] = false;
      return jsonData;
    };

	const sendCanvasImageToServer = function(data) {
		let cnv = $('canvas')[0];
		let sessionId = data['sessionId'];
		let eventTime = data['eventTime'];
		let dataURL = stage.toDataURL();
		$.ajax({
			type: "POST",
			url: "/image/".concat(sessionId),
			data: {
				sessionId: sessionId,
				imgBase64: dataURL,
				eventTime: eventTime,
			}
		}).done(function(o) {
			console.log('saved');
			var event = saveStateToImageResponseEvent(o);
			notifySaveStateToImageResponse(event);
		});
	};

	const timestampToHoursMinutes = function (ts) {
		let tsDate = new Date(ts);
		var h = tsDate.getHours();
		var m = tsDate.getMinutes();

		h = (h<10) ? '0' + h : h;
		m = (m<10) ? '0' + m : m;

		var output = h + ':' + m;
		return output;
	}

    const showCanvasImage = function(data) {
		var takeScreenshotBtn = $('#takeScreenshotBtn');
		var anchor = takeScreenshotBtn.find('a')[0];
		anchor.text = 'Снимок сделан';
		takeScreenshotBtn.toggleClass("finished");
		setTimeout(function() { 
			anchor.text = 'Сделать снимок';
			takeScreenshotBtn.toggleClass("finished");
		}, 3000);

		var topDiv = $("<div>").append(
				$('<img />')
				.attr({ src : '/images/screenshots/'+ data['image'], width: 84, height: 60})
			);
		var bottomDiv = $("<div class='eventtime'>").html(timestampToHoursMinutes(parseInt(data['eventTime'])));
		topDiv.append(bottomDiv);
		$('#iterations').append(topDiv);
    };

    const saveStateToImageEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'sendCanvasImageToServer';
	  jsonData['eventTime']  = Date.now();
      jsonData['sessionId']  = sessionId;
      jsonData['notify'] = false;
      return jsonData;
    };

    const saveStateToImageResponseEvent = function (imageResponse) {
      var jsonData = {};
      jsonData['event']  = 'showCanvasImage';
      jsonData['sessionId']  = sessionId;
      jsonData['image']  = imageResponse.imagePath;
	  jsonData['eventTime']  = imageResponse.eventTime;
      jsonData['notify'] = false;
      return jsonData;
    };

    const removeSelectedEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'removeSelected';
      jsonData['notify'] = false;
      return jsonData;
    };

    const copySelectedEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'copySelected';
      jsonData['notify'] = false;
      return jsonData;
    };

    const skewSelectedEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'skewSelected';
      jsonData['notify'] = false;
      return jsonData;
    };

    const removeAllEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'removeAll';
      jsonData['skipFromHistory']  = true;
      jsonData['notify'] = false;
      return jsonData;
    };

    const levelUpEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'levelUp';
      jsonData['notify'] = false;
      return jsonData;
    };

    const levelDownEvent = function () {
      var jsonData = {};
      jsonData['event']  = 'levelDown';
      jsonData['notify'] = false;
      return jsonData;
    };

    const shapeDrag = function(jsonData) {
		const stageWidth = stage.width();
		const stageHeight = stage.height();
		
      jsonData['nodes'].forEach((nd) => {
        var node = sandboxLayer.findOne(node => {
//          return node.getType() === 'Shape' && node._id == nd._id;
////		  return node.getType() === 'Shape' && node.getAttr('imgId') === nd.img_id;
		  return node.getType() === 'Shape' && node.getAttr('uuid') === nd.uuid;
        });
		const nodeAbsCoordinates = toAbsolute(nd.x, nd.y, stageWidth, stageHeight);
//        node?.setAttrs({x: nd.x, y: nd.y});
        node?.setAttrs({x: nodeAbsCoordinates.x, y: nodeAbsCoordinates.y});
      });
    };

    const meDrag = function(jsonData) {
		const stageWidth = stage.width();
		const stageHeight = stage.height();

      jsonData['nodes'].forEach((nd) => {
        var node = sandboxLayer.findOne(node => {
//          return node.getType() === 'Shape' && node._id == nd._id;
////		  return node.getType() === 'Shape' && node.getAttr('imgId') === nd.img_id;
		  return node.getType() === 'Shape' && node.getAttr('uuid') === nd.uuid;
        });
		const nodeAbsCoordinates = toAbsolute(nd.x, nd.y, stageWidth, stageHeight);
//        node?.setAttrs({x: nd.x, y: nd.y});
        node?.setAttrs({x: nodeAbsCoordinates.x, y: nodeAbsCoordinates.y});
      });
    };

    const shapeDragEvent = function (evt) {
      var ri = evt.target;
      var jsonData = {};
      jsonData['event']  = 'shapeDrag';
		const stageWidth = stage.width();
		const stageHeight = stage.height();

      var nodes = [];
      ri._nodes.forEach((node) => {
		let relativeCoordinates = toRelative(node.attrs.x, node.attrs.y, stageWidth, stageHeight);
        nodes.push({
          _id: node._id,
		  img_id: node.getAttr('imgId'),
		  uuid: node.getAttr('uuid'),
          x: relativeCoordinates.x,
          y: relativeCoordinates.y})
      });
      jsonData['nodes'] = nodes;
      jsonData['notify'] = false;
      return jsonData;
    };

	const meDragEventCmpFn = (evt1, evt2) => {
		return (evt2.event == 'meDrag' && evt2.nodes[0]._id == evt1.nodes[0]._id);
	};

    const meDragEvent = function (evt) {
		console.log("meDragEvent", evt);
		const stageWidth = stage.width();
		const stageHeight = stage.height();

      var me = evt.target;
	  let relativeCoordinates = toRelative(me.attrs.x, me.attrs.y, stageWidth, stageHeight);
      var jsonData = {};
      jsonData['event']  = 'meDrag';
      var nodes = [];
      nodes.push({
        _id: me._id,
		img_id: me.getAttr('imgId'),
		uuid: me.getAttr('uuid'),
        x: relativeCoordinates.x,
        y: relativeCoordinates.y});
      jsonData['nodes'] = nodes;
      jsonData['notify'] = false;
      jsonData['historyCmpFn'] = meDragEventCmpFn;
      return jsonData;
    };

    const transform = function(jsonData) {
      var transform = jsonData['transform'];
      var transformNode = sandboxLayer.findOne(node => {
//        return node.getType() === 'Group' && node._id == transform._id;
          return node.getType() === 'Shape' && node.attrs.uuid == transform.uuid;
      });
		const ch = stage.height();
		const cw = stage.width();
		const transformAbsoluteCoords = toAbsolute(transform.x, transform.y, cw, ch);

        transformNode?.setAttrs({
        offsetX:  transform.offsetX,
        offsetY:  transform.offsetY,
        rotation: transform.rotation,
        scaleX:   transform.scaleX,
        scaleY:   transform.scaleY,
        skewX:    transform.skewX,
        skewY:    transform.skewY,
//        x:        transform.x,
        x:        transformAbsoluteCoords.x,
//        y:        transform.y,
        y:        transformAbsoluteCoords.y,
      });

      jsonData['nodes'].forEach((nd) => {
        var node = sandboxLayer.findOne(node => {
//          return node.getType() === 'Shape' && node._id == nd._id;
////		  return node.getType() === 'Shape' && node.getAttr('imgId') == nd.img_id;
		  return node.getType() === 'Shape' && node.getAttr('uuid') == nd.uuid;
        });
		const nodeAbsoluteCoords = toAbsolute(nd.x, nd.y, cw, ch);

        node?.setAttrs({
          rotation: nd.rotation,
          scaleX: nd.scaleX,
          scaleY: nd.scaleY,
          skewX:  nd.skewX,
          skewY:  nd.skewY,
//          x:      nd.x,
          x:      nodeAbsoluteCoords.x,
//          y:      nd.y});
          y:      nodeAbsoluteCoords.y});
      });
    };

	const transformEventCmpFn = (evt1, evt2) => {
		return (evt2.event == 'transform' && evt2.nodes[0]._id == evt1.nodes[0]._id);
	};

    const transformEvent = function (evt) {
      var ri = evt.currentTarget;
//      var target = evt.target;
		const ch = stage.height();
		const cw = stage.width();
		
		const transformRlativeCoords = toRelative(ri.attrs.x, ri.attrs.y, cw, ch);

      var transform = {
        _id: ri._id,
//		uuid: target.attrs.uuid,
		uuid:     ri.attrs.uuid,
        offsetX:  ri.attrs.offsetX,
        offsetY:  ri.attrs.offsetY,
        rotation: ri.attrs.rotation,
        scaleX:   ri.attrs.scaleX,
        scaleY:   ri.attrs.scaleY,
        skewX:    ri.attrs.skewX,
        skewY:    ri.attrs.skewY,
//        x:        ri.attrs.x,
        x:        transformRlativeCoords.x,
//        y:        ri.attrs.y,
        y:        transformRlativeCoords.y,
      };

      var jsonData = {};
      jsonData['event']  = 'transform';
      var nodes = [];
      ri._nodes.forEach((node) => {
		const nodeRlativeCoords = toRelative(node.attrs.x, node.attrs.y, cw, ch);
        nodes.push({
          _id: node._id,
		  img_id: node.attrs.imgId,
		  uuid: node.attrs.uuid,
          rotation: node.attrs.rotation,
          scaleX: node.attrs.scaleX,
          scaleY: node.attrs.scaleY,
          skewX: node.attrs.skewX,
          skewY: node.attrs.skewY,
//          x:     node.attrs.x,
          x:     nodeRlativeCoords.x,
//          y:     node.attrs.y})
          y:     nodeRlativeCoords.y})
      });
      jsonData['nodes'] = nodes;
	  jsonData['transform'] = transform;
      jsonData['notify'] = false;
	  jsonData['historyCmpFn'] = transformEventCmpFn;
      return jsonData;
    };

      const calcScaledImageWidthHeight = function(image) {
        var width  = image.width;
        var height = image.height;
        var c  = width / height;
		var c1 = width / maxImageWidth;
		width = width / c1;
		height = width / c;
		if (height > maxImageHeight) {
			c1 = height / maxImageHeight;
			height = height / c1;
			width = height * c;
		}
        return [width, height];
      }

	function loadImage(imgSource, categoryId, imageId, uuid) {
		image = new Image();
		image.src = imgSource;
		const ch = stage.height();
		const cw = stage.width();
		let stageMiddleX = stage.width() >> 1;
		let stageMiddleY = stage.height() >> 1;

		image.onload = function() {
			var [imgWidth, imgHeight] = calcScaledImageWidthHeight(image);
			const ih = ch / ratio;	// Image Scaled Height
			const iw = imgWidth * ih / imgHeight;	// Image Scaled Width
			
			let newImageX = stageMiddleX - (iw >> 1);
			let newImageY = stageMiddleY - (ih >> 1);
			var pic = new Konva.Image({
				image: image,
				src: image.src,
				x: newImageX,
				y: newImageY,
				width: iw,
				height: ih,
				draggable: (clientMode || canDoctorEditImages) ? true : false,
				name: 'catpic',
			});
			pic.setAttr('category', categoryId);
			pic.setAttr('imgId', imageId);
			pic.setAttr('uuid',  uuid);
			pic.offsetX(pic.width() >> 1);

			sandboxLayer.add(pic);
			transformer.remove();
			sandboxLayer.add(transformer);
			transformer.nodes([pic]);
		}
	}

	function loadPositionedImage(imgSource, categoryId, imageId, x, y) {
		const ch = stage.height();
		const cw = stage.width();
		const absoluteCoordinates = toAbsolute(x, y, cw, ch);

		image = new Image();
		image.src = imgSource;
		image.onload = function() {
			var [imgWidth, imgHeight] = calcScaledImageWidthHeight(image);
			const ih = ch / ratio;	// Image Scaled Height
			const iw = imgWidth * ih / imgHeight;	// Image Scaled Width

			var pic = new Konva.Image({
				image: image,
				src: image.src,
//				x: x,
				x: absoluteCoordinates.x,
//				y: y,
				y: absoluteCoordinates.y,
				width: iw,
				height: ih,
				draggable: (clientMode || canDoctorEditImages) ? true : false,
				name: 'catpic',
			});
			pic.setAttr('category', categoryId);
			pic.setAttr('imgId', imageId);
			pic.offsetX(iw >> 1);
			pic.offsetY(ih >> 1);

			sandboxLayer.add(pic);
			transformer.remove();
			sandboxLayer.add(transformer);
			transformer.nodes([pic]);
		}
	}

      function removeSelected(data, notify = false) {
          transformer.nodes().forEach(function (currentValue, index, arr) {
              currentValue.destroy();
          });
          transformer.detach();
          sandboxLayer.draw();
          if (notify) {
            var event = removeSelectedEvent();
            notifyRemoveSelected(event);
          }
      }

	function copySelected() {
		transformer.nodes().forEach(function (currentValue, index, arr) {
			var clone = currentValue.clone();
			clone.attrs.x += 20;
			clone.attrs.y += 20;
			sandboxLayer.add(clone);
		});
		sandboxLayer.draw();
		if (notifyViewer) {
			var event = copySelectedEvent();
			notifyCopySelected(event);
		}
	}

	function skewSelected() {
		transformer.nodes().forEach(function (currentValue, index, arr) {
			currentValue.to({
				scaleX: -currentValue.scaleX(),
			});

			if (notifyViewer) {
				var event = skewSelectedEvent();
				notifySkewSelected(event);
			}
		});
	}

	function removeAllConfirmation() {
		showPopupDialog("#clearall-confirm-dialog");
	}

	function closeClearConfirmationDialog(remove) {
		closePopupDialog("#clearall-confirm-dialog");
		if (remove) {
			removeAll();
		}
	}

	function removeAll() {
		var nodes = sandboxLayer.find(node => {
			return 'Image' === node.className;
		});
		nodes.forEach(function (currentValue, index, arr) {
			currentValue.destroy();
		});

		transformer.nodes().forEach(function (currentValue, index, arr) {
			currentValue.destroy();
		});
		transformer.detach();
		sandboxLayer.draw();
		if (notifyViewer) {
			var event = removeAllEvent();
			notifyRemoveAll(event);
		}
	}

	const scaleAllSceneImagesOnLayer = (layer, oldW, oldH, newW, newH) => {
		if (0 < oldW && 0 < oldH) {
			var nodes = layer.find(node => {
				return 'Image' === node.className;
			});
			nodes.forEach(function (node, index, arr) {
				const coordinates = scale(node.x(), node.y(), oldW, oldH, newW, newH);
				const box = scale(node.width(), node.height(), oldW, oldH, newW, newH);
				const offset = scale(node.offsetX(), node.offsetY(), oldW, oldH, newW, newH);

				node.x(coordinates.x);
				node.y(coordinates.y);
				node.width(box.x);
				node.height(box.y);
				node.offsetX(offset.x);
				node.offsetY(offset.y);
			});
		}
	};

/*
	const scaleAllSceneImagesOnCanvasResize = (oldW, oldH, newW, newH) => {
		if (0 < oldW && 0 < oldH) {
			var nodes = sandboxLayer.find(node => {
				return 'Image' === node.className;
			});
			nodes.forEach(function (node, index, arr) {
				const coordinates = scale(node.x(), node.y(), oldW, oldH, newW, newH);
				const box = scale(node.width(), node.height(), oldW, oldH, newW, newH);
				const offset = scale(node.offsetX(), node.offsetY(), oldW, oldH, newW, newH);

				node.x(coordinates.x);
				node.y(coordinates.y);
				node.width(box.x);
				node.height(box.y);
				node.offsetX(offset.x);
				node.offsetY(offset.y);
			});
		}
	};
*/
	const scaleAllSceneImagesOnCanvasResize = (oldW, oldH, newW, newH) => {
		scaleAllSceneImagesOnLayer(sandboxLayer, oldW, oldH, newW, newH);
	};

      function levelUp() {
          transformer.nodes().forEach(function (currentValue, index, arr) {
//              currentValue.moveUp();
              currentValue.moveToTop();
//              if (notifyViewer) {
                var event = levelUpEvent();
                notifyLevelUp(event);
//              }
          });
      }

      function levelDown() {
          transformer.nodes().forEach(function (currentNode, index, arr) {
//              currentNode.moveDown();
              currentNode.moveToBottom();
//              if (notifyViewer) {
                var event = levelDownEvent();
                notifyLevelDown(event);
//              }
          });
      }

      function saveStateToImage() {
        var event = saveStateToImageEvent();
        notifySaveStateToImage(event);
      }

	// Helper functions for calculating bounding boxes
	function getCorner(pivotX, pivotY, diffX, diffY, angle) {
		const distance = Math.sqrt(diffX * diffX + diffY * diffY);

		// Find angle from pivot to corner
		angle += Math.atan2(diffY, diffX);

		// Get new x and y coordinates
		const x = pivotX + distance * Math.cos(angle);
		const y = pivotY + distance * Math.sin(angle);

		return {
			x,
			y
		};
	}

	// Calculate total bounding box of multiple shapes
	function getTotalBox(boxes) {
		let minX = Infinity;
		let minY = Infinity;
		let maxX = -Infinity;
		let maxY = -Infinity;

		boxes.forEach((box) => {
			minX = Math.min(minX, box.x);
			minY = Math.min(minY, box.y);
			maxX = Math.max(maxX, box.x + box.width);
			maxY = Math.max(maxY, box.y + box.height);
		});

		return {
			x: minX,
			y: minY,
			width: maxX - minX,
			height: maxY - minY,
		};
	}

	// Calculate client rect accounting for rotation
	function getClientRect(rotatedBox) {
		const {
			x,
			y,
			width,
			height
		} = rotatedBox;
		const rad = rotatedBox.rotation;

		const p1 = getCorner(x, y, 0, 0, rad);
		const p2 = getCorner(x, y, width, 0, rad);
		const p3 = getCorner(x, y, width, height, rad);
		const p4 = getCorner(x, y, 0, height, rad);

		const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
		const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
		const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
		const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

		return {
			x: minX,
			y: minY,
			width: maxX - minX,
			height: maxY - minY,
		};
	}

	const toRelative = (x, y, width, height) => {
		return {
			x: x / width,
			y: y / width};
	};

	const toAbsolute = (rx, ry, width, height) => {
		return {
			x: rx * width,
			y: ry * width};
	};

	const scale = (x, y, oldW, oldH, newW, newH) => {
		return {
			x: x * newW / oldW,
			y: y * newH / oldH};
	};

	function getCssRulePropertyOld(selector, property) {
		for (const sheet of document.styleSheets) {
			try {
				for (const rule of sheet.cssRules) {
					if (rule.selectorText === selector) {
						return rule.style.getPropertyValue(property);
					}
				}
			} catch (e) {
			}
		}
		return null;
	}

	function getCssRulePropertyOld1(selector, property) {
		for (const sheet of document.styleSheets) {
			try {
				for (const rule of sheet.cssRules) {
					// если это обычное правило
					if (rule.selectorText === selector) {
						return rule.style.getPropertyValue(property);
					}

					// если это @media
					if (rule.media && window.matchMedia(rule.media.mediaText).matches) {
						for (const subRule of rule.cssRules) {
							if (subRule.selectorText === selector) {
								return subRule.style.getPropertyValue(property);
							}
						}
					}
				}
			} catch (e) {
				// доступ до сторонніх стилів може кидати SecurityError
			}
		}
		return null;
	}


	function getCssRuleProperty(selector, property) {
		let lastNormal = null;
		let lastImportant = null;

		for (const sheet of document.styleSheets) {
			let rules;
			try {
				// можуть кидати SecurityError для зовнішніх стилів — в такому випадку пропускаємо
				rules = sheet.cssRules;
			} catch (e) {
				continue;
			}
			// не робимо "if (!rules) continue" — замість цього просто передамо в обробник
			processRules(rules, true);
		}

		function normalizeSelectorText(sel) {
			// прибираємо псевдо-класи/елементи (простий варіант) і trim
			return sel.replace(/::?[\w-]+(?:\([^\)]*\))?/g, '').trim();
		}

		function selectorMatches(ruleSelectorText, targetSelector) {
			if (!ruleSelectorText) return false;
			const parts = ruleSelectorText.split(',').map(s => s.trim());
			for (const p of parts) {
				if (p === targetSelector) return true; // точна співпадіння
				if (normalizeSelectorText(p) === targetSelector) return true; // наприклад ".rsideMin:hover" -> ".rsideMin"
			}
			return false;
		}

		function processRules(rules, applicable) {
			if (!rules) return; // нічого робити
			for (const rule of rules) {
				// @media
				if (rule.type === CSSRule.MEDIA_RULE) {
					const mediaText = rule.media && rule.media.mediaText || rule.conditionText || '';
					const matches = !!(mediaText && window.matchMedia(mediaText).matches);
					processRules(rule.cssRules, applicable && matches);
					continue;
				}

				// @supports
				if (rule.type === CSSRule.SUPPORTS_RULE) {
					let supportsMatch = true;
					if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
						try {
							// conditionText інколи називається по-різному в різних браузерах
							const cond = rule.conditionText || rule.cssText || '';
							supportsMatch = cond ? CSS.supports(cond) : true;
						} catch (e) {
							supportsMatch = true;
						}
					}
					processRules(rule.cssRules, applicable && supportsMatch);
					continue;
				}

				// @import
				if (rule.type === CSSRule.IMPORT_RULE) {
					try {
						const imported = rule.styleSheet || rule.styleSheet;
						if (imported) processRules(imported.cssRules, applicable);
					} catch (e) { /* пропускаємо */ }
					continue;
				}

				// звичайне стилеве правило
				if (rule.type === CSSRule.STYLE_RULE) {
					if (!applicable) continue;
					if (selectorMatches(rule.selectorText, selector)) {
						const val = rule.style.getPropertyValue(property);
						if (!val) continue;
						const priority = rule.style.getPropertyPriority(property); // 'important' або ''
						if (priority === 'important') lastImportant = val.trim();
						else lastNormal = val.trim();
					}
					continue;
				}

				// інші групи правил (якщо є вкладені cssRules)
				if (rule.cssRules) {
					try { processRules(rule.cssRules, applicable); } catch (e) { /* ignore */ }
				}
			}
		}

		return lastImportant !== null ? lastImportant : lastNormal;
	}


	function initStage() {
		let containerElement = $('#container');
		let selectionRectangle = new Konva.Rect({
			fill: 'rgba(0,0,255,0.5)',
			visible: false,
		});

		stage = new Konva.Stage({
			container: 'container',
			width: containerElement.width(),
			height: containerElement.height(),
		});
		sandboxLayer = new Konva.Layer({name: 'sandboxLayer', id: 'sandboxLayer'});
		backgroundLayer = new Konva.Layer({name: 'backgroundLayer', id: 'backgroundLayer'});

		const container = stage.container();

		container.addEventListener('dragover', function (e) {
			e.preventDefault();
		});

		container.addEventListener('drop', function (e) {
			e.preventDefault();
			const pointerPosition = stage.getPointerPosition();

			const imageURL = e.dataTransfer.getData('text/uri-list') || e.dataTransfer.getData('text/plain');
			const catIdAttr = e.dataTransfer.getData('catId');
			const imgIdAttr = e.dataTransfer.getData('imgId');
			const relativeCoordinates = toRelative(e.layerX, e.layerY, stage.width(), stage.height());
			
			positionedImageSelect(positionedImageSelectEvent(imageURL, catIdAttr, imgIdAttr, relativeCoordinates.x, relativeCoordinates.y), notifyViewer);
		});

		transformer = new Konva.Transformer({
			enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
			resizeEnabled: (clientMode || canDoctorEditImages) ? true : false,
			rotateEnabled: (clientMode || canDoctorEditImages) ? true : false,
			borderStroke: '#244A65',
			anchorStroke: '#244A65',
			boundBoxFunc: (oldBox, newBox) => {
				// Calculate the actual bounding box of the transformed shape
				const box = getClientRect(newBox);

				// Check if the new box is outside the stage boundaries
				const isOut =
					(box.x - sandboxBorderLeftWidth) < 0 ||
					(box.y - sandboxBorderTopHeight) < 0 ||
					(box.x + box.width + sandboxBorderBottomHeight) > stage.width() ||
					(box.y + box.height + sandboxBorderRightWidth) > stage.height();

				// If outside boundaries, keep the old box
				if (isOut) {
					return oldBox;
				}

				// If within boundaries, allow the transformation
				return newBox;
			},
		});

		transformer.on('transform', function(evt) {
			if (clientMode || canDoctorEditImages) {
//				if (notifyViewer) {
					var event = transformEvent(evt);
					notifyTransform(event);
//				}
			}
		});
		transformer.on('dragmove', function(evt) {
			if (clientMode || canDoctorEditImages) {
				const boxes = transformer.nodes().map((node) => node.getClientRect());

				// Get the total bounding box of all shapes
				const box = getTotalBox(boxes);

				// Keep shapes within stage boundaries
				transformer.nodes().forEach((node) => {
					const absPos = node.getAbsolutePosition();

					// Calculate node position relative to group bounding box
					const offsetX = box.x - absPos.x;
					const offsetY = box.y - absPos.y;

					// Adjust position if outside boundaries
					const newAbsPos = {
						...absPos
					};

					if (box.x < sandboxBorderLeftWidth) {
						newAbsPos.x = -offsetX + sandboxBorderLeftWidth;
					}
					if (box.y < sandboxBorderTopHeight) {
						newAbsPos.y = -offsetY + sandboxBorderTopHeight;
					}
					if (box.x + box.width > stage.width() - sandboxBorderRightWidth) {
						newAbsPos.x = stage.width() - box.width - offsetX - sandboxBorderRightWidth;
					}
					if (box.y + box.height > stage.height() - sandboxBorderBottomHeight) {
						newAbsPos.y = stage.height() - box.height - offsetY - sandboxBorderBottomHeight;
					}

					node.setAbsolutePosition(newAbsPos);
				});
//				if (notifyViewer) {
					var dragEvent = shapeDragEvent(evt);
					notifyShapeDrag(dragEvent);
//				}
			}
		});

		sandboxLayer.add(transformer);
		sandboxLayer.add(selectionRectangle);

		sandboxLayer.on('click', function(evt) {
			console.log(evt);
			var shape = evt.target;
//			var group = evt.currentTarget;
			if (notifyViewer) {
				var clickEvent = shapeClickEvent(shape);
				notifyShapeClick(clickEvent);
			}
		});

		sandboxLayer.on('dragmove', function(evt) {
			if (clientMode || canDoctorEditImages) {
				let node = evt.target;
				const boxes = [node.getClientRect()];

				// Get the total bounding box of all shapes
				const box = getTotalBox(boxes);

				// Keep shapes within stage boundaries
//				transformer.nodes().forEach((node) => {
					const absPos = node.getAbsolutePosition();

					// Calculate node position relative to group bounding box
					const offsetX = box.x - absPos.x;
					const offsetY = box.y - absPos.y;

					// Adjust position if outside boundaries
					const newAbsPos = {
						...absPos
					};

					if (box.x < sandboxBorderLeftWidth) {
						newAbsPos.x = -offsetX + sandboxBorderLeftWidth;
					}
					if (box.y < sandboxBorderTopHeight) {
						newAbsPos.y = -offsetY + sandboxBorderTopHeight;
					}
					if (box.x + box.width > stage.width() - sandboxBorderRightWidth) {
						newAbsPos.x = stage.width() - box.width - offsetX - sandboxBorderRightWidth;
					}
					if (box.y + box.height > stage.height() - sandboxBorderBottomHeight) {
						newAbsPos.y = stage.height() - box.height - offsetY - sandboxBorderBottomHeight;
					}

					node.setAbsolutePosition(newAbsPos);
//				});
//				if (notifyViewer) {
					var event = meDragEvent(evt);
					notifyMeDrag(event);
//				}
			}
		});

		stage.add(backgroundLayer, sandboxLayer);

		backgroundImage = new Image();
		backgroundImage.src = "/images/sandbox/sandbox.jpg";

		backgroundImage.onload = function() {
			backgroundImage.width = stage.width();
			backgroundImage.height = stage.height();

			background = new Konva.Image({
				name: 'backgroundImg',
				id: 'backgroundImg',
				src: backgroundImage.src,
				imgWidth: backgroundImage.width,
				imgHeight: backgroundImage.height,
				x: 0,
				y: 0,
				width: stage.width(),
				height: stage.height(),
				listening: false,
				strokeScaleEnabled: false
			});
			background.image(backgroundImage);
			backgroundLayer.add(background);
			recalcSandboxSizes();
		}

		let x1, y1, x2, y2;
		stage.on('mousedown touchstart', (e) => {
			// do nothing if we mousedown on any shape
			if (e.target !== stage) {
				return;
			}
			x1 = stage.getPointerPosition().x;
			y1 = stage.getPointerPosition().y;
			x2 = stage.getPointerPosition().x;
			y2 = stage.getPointerPosition().y;

			selectionRectangle.visible(true);
			selectionRectangle.width(0);
			selectionRectangle.height(0);
		});

		stage.on('mousemove touchmove', () => {
			// do nothing if we didn't start selection
			if (!selectionRectangle.visible()) {
				return;
			}
			x2 = stage.getPointerPosition().x;
			y2 = stage.getPointerPosition().y;

			selectionRectangle.setAttrs({
				x: Math.min(x1, x2),
				y: Math.min(y1, y2),
				width: Math.abs(x2 - x1),
				height: Math.abs(y2 - y1),
			});
		});

		stage.on('mouseup touchend', () => {
			// do nothing if we didn't start selection
			if (!selectionRectangle.visible()) {
				return;
			}
			// update visibility in timeout, so we can check it in click event
			setTimeout(() => {
				selectionRectangle.visible(false);
			});

			var shapes = stage.find('.catpic');
			var box = selectionRectangle.getClientRect();
			var selected = shapes.filter((shape) =>
					Konva.Util.haveIntersection(box, shape.getClientRect()));
			transformer.nodes(selected);
		});

		// clicks should select/deselect shapes
		stage.on('click tap', function (e) {
			// if we are selecting with rect, do nothing
			if (selectionRectangle.visible()) {
				return;
			}

			// if click on empty area - remove all selections
			if (e.target === stage) {
				transformer.nodes([]);
				return;
			}

			// do nothing if clicked NOT on our rectangles
			if (!e.target.hasName('catpic')) {
				return;
			}

			// do we pressed shift or ctrl?
			const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;
			const isSelected = transformer.nodes().indexOf(e.target) >= 0;

			if (!metaPressed && !isSelected) {
				// if no key pressed and the node is not selected
				// select just one
				transformer.nodes([e.target]);
			} else if (metaPressed && isSelected) {
				// if we pressed keys and node was selected
				// we need to remove it from selection:
				const nodes = transformer.nodes().slice(); // use slice to have new copy of array
				// remove node from array
				nodes.splice(nodes.indexOf(e.target), 1);
				transformer.nodes(nodes);
			} else if (metaPressed && !isSelected) {
				// add the node into selection
				const nodes = transformer.nodes().concat([e.target]);
				transformer.nodes(nodes);
			}
		});

	}

	var oldSandboxWidth  = -1;
	var oldSandboxHeight = -1;
	
	const recalcSandboxSizes = function(evt) {
		let screenWidth = window.innerWidth;
		let screenHeight = window.innerHeight;
		const sizeRelations = 7/5;
		let rSideContentElement = $('.rsidecontent');
//		let rSideContentWidth  = rSideContentElement.width();
		let rSideContentWidth  = parseFloat(getCssRuleProperty('.rsideMin', 'width'));
		let rSideContentHeight = rSideContentElement.height();
		let minRsideWidth = rSideContentWidth + 10;

		const leftSideWidth = $('.left_side_menu').width();
		let sandboxWidth = screenWidth - leftSideWidth - minRsideWidth;
		const categoryImagesStyleRightShift = parseFloat(getCssRuleProperty('#categoryImages', 'right'));
		categoryImageMaxPanelWidth = screenWidth - leftSideWidth - categoryImagesStyleRightShift;

		const columnGap = getCssRuleProperty('.images_visible', 'column-gap');
		const w1 = $('.imageCell').width();
		const w2 = parseFloat(columnGap);
		let rightSideMinWidth = 3 * w1 + 2 * w2;

		let sandboxHeight = sandboxWidth / sizeRelations;
		if (sandboxHeight > screenHeight) {
			sandboxHeight = screenHeight;
			sandboxWidth = sandboxHeight * sizeRelations;
		}

		let rightSideWidth = (screenWidth - sandboxWidth - leftSideWidth);
		const categoryColumnCountInWidth = Math.floor((rightSideWidth + w2) / (w1 + w2));
		rightSideWidth = Math.max(rightSideWidth, categoryColumnCountInWidth * (w1 + w2) - w2);
		rSideContentElement.width(rightSideWidth);

console.log({
	'sandboxWidth' : sandboxWidth,
	'sandboxHeight' : sandboxHeight,
	'screenWidth' : screenWidth,
	'screenHeight' : screenHeight,
	'leftSideWidth' : leftSideWidth,
	'rightSideWidth' : rightSideWidth,
	'rSideContentWidth' : rSideContentWidth,
	'w1' : w1,
	'w2' : w2,
	'categoryColumnCountInWidth' : categoryColumnCountInWidth});

		sandboxWidth = screenWidth - rightSideWidth - leftSideWidth;
		sandboxHeight = sandboxWidth / sizeRelations;
		if (sandboxHeight > screenHeight) {
			sandboxHeight = screenHeight;
			sandboxWidth = sandboxHeight * sizeRelations;
		}

console.log({
	'sandboxWidth' : sandboxWidth,
	'sandboxHeight' : sandboxHeight,
	'screenWidth' : screenWidth,
	'screenHeight' : screenHeight,
	'leftSideWidth' : leftSideWidth,
	'rightSideWidth' : rightSideWidth, });
/*
		const columnGap = getCssRuleProperty('.images_visible', 'column-gap');
		let rightSideWidth = 3 * $('.imageCell').width() + 2 * parseFloat(columnGap);
*/
//		categoryImageMinPanelWidth = rightSideWidth + 10;
		categoryImageMinPanelWidth = rightSideWidth - categoryImagesStyleRightShift;

		let element = document.getElementById('sandbox');
		element.width  = sandboxWidth + 'px';
		element.height = sandboxHeight + 'px';

		element = document.getElementById('container');
		element.style.width  = sandboxWidth + 'px';
		element.style.height = sandboxHeight + 'px';
		let iterationHolderWidth = sandboxWidth * iterationHolderSandboxWidthPercent / 100.0;
		let iterationHolderLeft = leftSideWidth + ((sandboxWidth - iterationHolderWidth) >> 1);
		$("#iterationsHolder").css('width', iterationHolderWidth + 'px');
		$("#iterationsHolder").css('bottom', (((screenHeight - sandboxHeight) >> 1) + 2) + 'px');
		$("#iterationsHolder").css('left', iterationHolderLeft + 'px');
		$("#slideToggle").css('left', (iterationHolderWidth  >> 1) + 'px');
		
		element = document.getElementById('rside');
		element.width  = rightSideWidth + 'px';

		element = document.getElementById('categoryImages');
		let categoryImageHeight = screenHeight - rSideContentHeight;
		element.style.height = categoryImageHeight + 'px';
//		element.style.width = (rSideContentWidth + 10) + 'px';
//		const categoryImagesStyleRightShift = parseFloat(getCssRuleProperty('#categoryImages', 'right'));
		element.style.width = (categoryImageMinPanelWidth - categoryImagesStyleRightShift) + 'px';
//		element.style.width = categoryImageMinPanelWidth + 'px';

		let topCategoriesHeight = $("#top_categories").height();
		var slider = $("#categoryImageSlider");
		slider.css('top', ((categoryImageHeight >> 1) - (topCategoriesHeight >> 1) ) + 'px');

		if (typeof stage !== 'undefined') {
			scaleAllSceneImagesOnCanvasResize(oldSandboxWidth, oldSandboxHeight, sandboxWidth, sandboxHeight);
			stage.width(sandboxWidth);
			stage.height(sandboxHeight);
			if (typeof background !== 'undefined') {
				backgroundImage.width = sandboxWidth;
				backgroundImage.height = sandboxHeight;
				background.width(sandboxWidth);
				background.height(sandboxHeight);
			}

			stage.draw();
		}
		oldSandboxWidth  = sandboxWidth;
		oldSandboxHeight = sandboxHeight;
	};

	window.addEventListener('resize', recalcSandboxSizes, true);

	const updateConnectionState = function(connected, middle = false) {
	<% if (clientMode) { %>
		let imgSrc = connected ? "/images/svg/connectionStatusConnected.svg" : (middle ? "/images/connect.gif" : "/images/svg/connectionStatusDisconnected.svg");
		$("#connectionStatusImg").attr("src",imgSrc);
		let statusLabel = connected ? "Сессия активна" : (middle ? "Соединяем..." :"Сессия неактивна");
		$("#connectionStatusLabel").text(statusLabel);
		if (connected) {
			$("#connectionStatusLabel").addClass('connectionEstablishet');
		} else {
			$("#connectionStatusLabel").removeClass('connectionEstablishet');
		}
	<% } %>
	}

	const updateCategoryLabel = function(label, bold) {
		$('#category_label').text( label );
		if (bold) {
			$('#category_label').css( "font-weight", "bold" );
		} else {
			$('#category_label').css( "font-weight", "normal" );
		}
	};

	const categoryHoverIn = function() {
		updateCategoryLabel($(this).attr('cname'));
	};
	const categoryHoverOut = function() {
		if (typeof selectedCategoryName !== 'undefined') {
			updateCategoryLabel(selectedCategoryName, true);
		} else {
			updateCategoryLabel("");
		}
	};

    const notifyCategorySelect = function (jsonData) {
      sendEvent(jsonData);
    };

    const selectedCategoryClassName = "cselected";

	const unselectPreviousCategory = function () {
		if (prevCategoryId) {
			let catElement = $("[cid="+prevCategoryId+"]");
			catElement.removeClass(selectedCategoryClassName);
			catElement.children('img').attr("src", catElement.attr("icon"));
			updateCategoryLabel("");
		}
	}

    var prevShownCategoryId = "01";
    function showImages(catecory) {
		$("#images_" + prevShownCategoryId).removeClass('images_visible');
		prevShownCategoryId = catecory;
		$("#images_" + prevShownCategoryId).addClass('images_visible');
    }

	var selectedCategoryId;
	var selectedCategoryName;
	const selectCategory = function (categoryId, categoryName) {
		unselectPreviousCategory();
		let catElement = $("[cid="+categoryId+"]");
		catElement.addClass(selectedCategoryClassName);
		catElement.children("img").attr("src", catElement.attr("inverticon"));
		prevCategoryId = categoryId;
		updateCategoryLabel(categoryName, true);
		selectedCategoryId = categoryId;
		selectedCategoryName = categoryName;
	}

    const categorySelect = function (jsonObject, notify = false) {
      selectCategory(jsonObject['categoryId'], jsonObject['categoryName']);
      showImages(jsonObject['categoryId']);
      if (notify) {
        notifyCategorySelect(jsonObject);
      }
    };

	const categorySelectEventCmpFn = (evt1, evt2) => {
		return (evt2.event == 'categorySelect' && evt2.categoryId == evt1.categoryId);
	};

    const categorySelectEvent = function(categoryId, categoryName, notify) {
      var jsonData = {};
      jsonData['event'] = 'categorySelect';
      jsonData['categoryId'] = categoryId;
      jsonData['categoryName'] = categoryName;
      jsonData['notify'] = notify;
	  jsonData['historyCmpFn'] = categorySelectEventCmpFn;
      return jsonData;
    };

	const selectFirstCategoryFromStart = function() {
		// Надо найти первую катерогию в списке, взять ее ID ("cid" аттрибут) и выбрать ее
		let allCategories = $(".topCategory");
		if (typeof allCategories !== 'undefined') {
			categorySelect(categorySelectEvent(allCategories[0].attributes['cid'].value, allCategories[0].attributes['cname'].value), true);
		}
	};

	const copyInliteLinkToClipboard = async function(inviteJson) {
		await copyContent(inviteJson.sessionLink);
	};

	const copyContent = async function(text){
		try {
			await navigator.clipboard.writeText(text);
			console.log('Content copied to clipboard');
		} catch (err) {
			console.error('Failed to copy: ', err);
		}
	};

	const showInvitePopup = function(inviteJson) {
		invitePopupDialog.dialog( "open" );
		$("#sessionLink").text(inviteJson.sessionLink);
	};

	const inviteClient = function() {
		var inviteClientBtn = $('#inviteClientBtn');
		inviteClientBtn.addClass("pressed");
		$.ajax({
			type: "POST",
			url: "/session/init"
		}).done(function(res) {
			console.log('invited');
			copyInliteLinkToClipboard(res);
			showInvitePopup(res);
			saveP2PDataToLocalStorage(res.sessionId, res.opponentSessionId, false);
			launchPeer(res.sessionId, res.opponentSessionId, false);
//			launchPeer('1', '2', false);

			inviteClientBtn.removeClass("pressed");
			var anchor = inviteClientBtn.find('a')[0];
			anchor.text = "Ссылка скопирована";
			inviteClientBtn.off('click');
		});
	};

	const saveP2PDataToLocalStorage = (clientId, targetId, initDataChannel) => {
		const p2pSettings = {
			clientId: clientId,
			targetId: targetId,
			initDataChannel: initDataChannel
		};
		console.log("saveP2PDataToLocalStorage", p2pSettings);
		localStorage.setItem('p2psettings', JSON.stringify(p2pSettings));
	};

	const loadP2PDataFromLocalStorage = () => {
		const p2pSettings = JSON.parse(localStorage.getItem('p2psettings'));
		console.log("loadP2PDataFromLocalStorage", p2pSettings);
		return p2pSettings;
	};

	const saveKonvaState = () => {
		const data = stage.toJSON();
//		console.log("saveKonvaState", data);
		localStorage.setItem('konvaAppState', data);
//		const historyRecord = JSON.stringify(eventHistory);
//		localStorage.setItem('eventHistory', historyRecord);
//		console.log(`History Record Size: ${historyRecord.length} bytes`);
	};

	const stageFromJson = async (stageJson) => {
		if (stageJson) {
//			let containerElement = $('#container')[0];
			let containerElement = $('#containerHidden')[0];
			const originalStage = stage;
			const originalSandboxWidth = originalStage.width();
			const originalSandboxHeight = originalStage.height();
//			const stageReload = Konva.Node.create(JSON.parse(stageJson), containerElement);
			const stageReload = Konva.Node.create(JSON.parse(stageJson), containerElement);
			const sandboxLayerReload = stageReload.findOne('#sandboxLayer');
			const backgroundLayerReload = stageReload.findOne('#backgroundLayer');
			background = backgroundLayerReload.findOne('#backgroundImg');

//			scaleAllSceneImagesOnLayer(sandboxLayer, stage.width(), stage.height(), originalSandboxWidth, originalSandboxHeight);
//			scaleAllSceneImagesOnLayer(backgroundLayer, stage.width(), stage.height(), originalSandboxWidth, originalSandboxHeight);
//			stage.width(originalSandboxWidth);
//			stage.height(originalSandboxHeight);
/*
			if (typeof background !== 'undefined') {
				backgroundImage.width = originalSandboxWidth;
				backgroundImage.height = originalSandboxHeight;
				background.width(originalSandboxWidth);
				background.height(originalSandboxHeight);
			}
*/

//			stage.find('Image').forEach((imageNode) => {
			sandboxLayerReload.find('Image').forEach((imageNode) => {
				const src = imageNode.getAttr('src'); // Retrieve the saved source
				const image = new Image();
				image.onload = () => {
					imageNode.image(image);
					imageNode.getLayer().batchDraw();
				};
				image.src = src; // Load the image from the source
				const imgWidth  = imageNode.getAttr('imgWidth'); // Retrieve the saved image width
				const imgHeight = imageNode.getAttr('imgHeight'); // Retrieve the saved image height
				if (imgWidth) {
					image.width = imgWidth;
				}
				if (imgHeight) {
					image.height = imgHeight;
				}

				sandboxLayer.add(imageNode);
				transformer.remove();
				sandboxLayer.add(transformer);
				transformer.nodes([imageNode]);
			});

			backgroundLayerReload.find('Image').forEach((imageNode) => {
				const src = imageNode.getAttr('src'); // Retrieve the saved source
				const image = new Image();
				image.onload = () => {
					imageNode.image(image);
					imageNode.getLayer().batchDraw();
				};
				image.src = src; // Load the image from the source
				image.width = originalSandboxWidth;
				image.height = originalSandboxHeight;
				imageNode.width(originalSandboxWidth);
				imageNode.height(originalSandboxHeight);
				backgroundImage = image;
			});

		}
	};

	const loadKonvaState = async () => {
		const stored = localStorage.getItem('konvaAppState');
		await stageFromJson(stored);
/*
		if (stored) {
			let containerElement = $('#container')[0];
			stage = Konva.Node.create(JSON.parse(stored), containerElement);

			stage.find('Image').forEach((imageNode) => {
				const src = imageNode.getAttr('src'); // Retrieve the saved source
				const image = new Image();
				image.onload = () => {
					imageNode.image(image);
					imageNode.getLayer().batchDraw();
				};
				image.src = src; // Load the image from the source
			});
		}
*/
	};

	const loadKonvaStateNew = async function () {
		const eventHistoryLS = localStorage.getItem('eventHistory');
		eventHistory = JSON.parse(eventHistoryLS || '[]');
		for (const event of eventHistory) {
//		eventHistory.forEach(event => async {
			event.fromHistory = true;
			onMessage(event);
			sendEvent(event);
			await sleep(30);
		}
	};

	const onConnectionClosed = function() {
	<% if (!clientMode) { %>
		var inviteClientBtn = $('#inviteClientBtn');
		inviteClientBtn.removeClass('closeSessionBtn');
		var anchor = inviteClientBtn.find('a')[0];
		anchor.text = "Пригласить клиента";
		inviteClientBtn.off('click').on('click', inviteClient);
	<% } %>
	}

	const onConnectionEstablished = function() {
	<% if (!clientMode) { %>
		var inviteClientBtn = $('#inviteClientBtn');
		inviteClientBtn.addClass('closeSessionBtn');
		var anchor = inviteClientBtn.find('a')[0];
		anchor.text = "Завершить сессию";
		inviteClientBtn.off('click').on('click', disconnectPeer);
	<% } %>
	}

	const disconnectPeer = function(eventData) {
		if (!eventData || !eventData.event) {
			sendEvent(disconnectEvent());
		}
//		myPeer?.destroy();
		myConn?.close();
		onConnectionClosed();
		sessionStorage.clear();
		localStorage.clear();
	}

	function onMessage(data) {
		console.log("✉️ Message:", data);
		if (typeof data === 'object' && data.hasOwnProperty('event')) {
			try {
				eval(data.event)(data);
//				saveKonvaState();
			} catch (ex) {
				console.log(ex);
			}
		}
	}

	const restoreOpponentStage = async () => {
		const event = restoreStateEvent(stage.toJSON());
		sendEvent(event);
	};

	async function onStatusChange(state) {
		console.log("⚡ Status:", state);
		if (state === 'connected') {
			showStatus("✅ Подключено", "green");
			updateConnectionState(true);
			onConnectionEstablished();
		<%if (clientMode) { %>
//			await loadKonvaState();
			await reLoadStateAfterReconnect();
			await restoreOpponentStage();
			const eventHistoryLS = localStorage.getItem('eventHistory')
			if (!firstCategorySelected && !eventHistoryLS) {
				selectFirstCategoryFromStart();
				firstCategorySelected = true;
			}
		<% } %>
		} else if (state === 'ws-closed') {
		} else if (state === 'ws-reconnecting') {
		} else if (state === 'disconnected') {
			saveKonvaState();
			updateConnectionState(false);
			showStatus("❌ Соединение потеряно", "red");
		} else if (state === 'reconnecting') {
			showStatus("🔄 Попытка повторного подключения...", "yellow");
		}
	}

	const reLoadStateAfterReconnect = () => {
		removeAll();
		loadKonvaState();
	};

	const launchPeer = async function(sessionId, opponentSessionId, isDataChannelInitiator = true, onConnectionHandler) {
		console.log("launchPeer", sessionId, opponentSessionId);
//		const myConn = startP2PConnection(sessionId, opponentSessionId, onMessage, onStatusChange);
//		myConn = startP2PConnection(sessionId, opponentSessionId, isDataChannelInitiator, onMessage, onStatusChange);
		myConn = await startP2PConnectionAsync(sessionId, opponentSessionId, isDataChannelInitiator, onMessage, onStatusChange);
		if (onConnectionHandler) onConnectionHandler();
		myConn.send(`Hi ${opponentSessionId}`);

		// Перевірити статус
		if (myConn.isConnected()) {
			myConn.send("Connected");
		}
	};

	const getElementWidth = function(element) {
		let width = element.attr('width');
		if (!width) {
			width = element.css('width');
		}
		if (!width) {
			width = element.width();
		}
		return width;
	}

	const getElementHeight = function(element) {
		let height = element.attr('height');
		if (!height) {
			height = element.css('height');
		}
		if (!height) {
			height = element.height();
		}
		return height;
	}

	const closePopupDialog = function(popupId) {
		let element = $(popupId);
		element.removeClass('popup');
		element.hide();
	}

	const showPopupDialog = function(popupId) {
		let screenOuterWidth  = window.outerWidth;
		let screenOuterHeight = window.outerHeight;
		let element = $(popupId);
		let elementWidth  = getElementWidth(element);
		let elementHeight = getElementHeight(element);
		let elTop  = (screenOuterHeight / 2 - elementHeight / 2);
		let elLeft = (screenOuterWidth / 2  - elementWidth / 2);
		element.hide();
		element.addClass('popup');
		element.css({top: elTop, left: elLeft, width: elementWidth + 'px', height: elementHeight + 'px'});
		element.show();
	};

	const processHotKeys = (event) => {
		let altPart = (event.altKey) ? "alt_" : "";
		let ctrlPart = (event.ctrlKey) ? "ctrl_" : "";
		let shiftPart = (event.shiftKey) ? "shift_" : "";
		let hotkeyKey = altPart + ctrlPart + shiftPart + event.key;
		const selector = "*[hotkey='" + hotkeyKey + "']";
		const hotkeyElement = document.querySelector(selector);
		if (hotkeyElement) {
			hotkeyElement.click();
		}
	};

	const loadSandboxWithProgress = async () => {
		const images = Array.from(document.querySelectorAll('img[data-src]'));
		const total = images.length;
		let loaded = 0;

		const updateProgress = () => {
			const percent = Math.round((loaded / total) * 100);
			document.getElementById('progress-value').textContent = percent;
		};

		const loadImage = (img) => {
			return new Promise((resolve, reject) => {
				const tempImg = new Image();
				tempImg.onload = () => {
					img.src = tempImg.src;
					++loaded;
					updateProgress();
					resolve();
				};
				tempImg.onerror = reject;
				tempImg.src = img.getAttribute('data-src');
			});
		};

		const cores = navigator.hardwareConcurrency || 4; // fallback на 4, if brawser not support
		const MAX_PARALLEL = cores;
		console.log(`Logic code count: ${MAX_PARALLEL}`);

		const queue = images.slice();
		const workers = new Array(MAX_PARALLEL).fill(null).map(async () => {
			while (queue.length > 0) {
				const img = queue.shift();
				try {
					await loadImage(img);
				} catch (e) {
					console.error('Image load error', img.getAttribute('data-src'));
				}
			}
		});

		await Promise.all(workers);

		console.log("All images loaded");
		document.getElementById('progress').style.display = 'none';
	};

  $( function() {
    var dialog, form,
 
      // From https://html.spec.whatwg.org/multipage/input.html#e-mail-state-%28type=email%29
      emailRegex = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
      name = $( "#name" ),
      email = $( "#email" ),
      password = $( "#password" ),
      allFields = $( [] ).add( name ).add( email ).add( password ),
      tips = $( ".validateTips" );

    <% if (typeof sessionId !== 'undefined') { %>

//	launchPeer('<%=sessionId %>', '<%=opponentSessionId %>');
//	launchPeer('<%=opponentSessionId %>', '<%=sessionId %>', true, reLoadStateAfterReconnect);
	launchPeer('<%=opponentSessionId %>', '<%=sessionId %>', true);
//	launchPeer('2', '1', true);

    <% } %>

    function updateTips( t ) {
      tips
        .text( t )
        .addClass( "ui-state-highlight" );
      setTimeout(function() {
        tips.removeClass( "ui-state-highlight", 1500 );
      }, 500 );
    }
 
    function checkLength( o, n, min, max ) {
      if ( o.val().length > max || o.val().length < min ) {
        o.addClass( "ui-state-error" );
        updateTips( "Length of " + n + " must be between " +
          min + " and " + max + "." );
        return false;
      } else {
        return true;
      }
    }
 
    function checkRegexp( o, regexp, n ) {
      if ( !( regexp.test( o.val() ) ) ) {
        o.addClass( "ui-state-error" );
        updateTips( n );
        return false;
      } else {
        return true;
      }
    }
 
    function addUser() {
      var valid = true;
      allFields.removeClass( "ui-state-error" );
 
      valid = valid && checkLength( name, "username", 3, 16 );
      valid = valid && checkLength( email, "email", 6, 80 );
      valid = valid && checkLength( password, "password", 5, 16 );
 
      valid = valid && checkRegexp( name, /^[a-z]([0-9a-z_\s])+$/i, "Username may consist of a-z, 0-9, underscores, spaces and must begin with a letter." );
      valid = valid && checkRegexp( email, emailRegex, "eg. ui@jquery.com" );
      valid = valid && checkRegexp( password, /^([0-9a-zA-Z])+$/, "Password field only allow : a-z 0-9" );
 
      if ( valid ) {
        $( "#users tbody" ).append( "<tr>" +
          "<td>" + name.val() + "</td>" +
          "<td>" + email.val() + "</td>" +
          "<td>" + password.val() + "</td>" +
        "</tr>" );
        dialog.dialog( "close" );
      }
      return valid;
    }

	var imagesRightPanel = $("#categoryImagesHolder");
	$( ".images_hidden" ).each(function(){
		$(this).remove();
		imagesRightPanel.append($(this));
	});


	$( "#tabs" ).tabs();

    dialog = $( "#dialog-form" ).dialog({
      autoOpen: false,
      height: 400,
      width: 400,
      modal: true,
      close: function() {
        form[ 0 ].reset();
        allFields.removeClass( "ui-state-error" );
      }
    });

	invitePopupDialog = $( "#invite-dialog" ).dialog({
		autoOpen: false,
		height: 453,
		width: 643,
	});

    $(".topCategory").hover( categoryHoverIn, categoryHoverOut );

    $(".topCategory").on("click", function() {
      var categoryId = $(this).attr("cid");
      var categoryName = $(this).attr("cname");
      categorySelect(categorySelectEvent(categoryId, categoryName), true);
    });

    $( "#login" ).on( "click", function() {
      dialog.dialog( "open" );
    });

	$("#slideToggle").click(function(){
		$(this).toggleClass("slideUp");
		$(this).toggleClass("slideDown");
		$("#iterations").slideToggle("slow");
	});
	var categoryImagesSate = 0;
	$("#categoryImageSlider").click(function(){
		$(this).toggleClass("slideLeft");
		$(this).toggleClass("slideRight");
		if (0 == categoryImagesSate) {
			$("#categoryImages").animate({width: categoryImageMaxPanelWidth + 'px'}, "fast");
//			$(".images_visible").animate({width: (categoryImageMaxPanelWidth-50) + 'px', display: 'block'}, "fast");
			$(".images_visible").animate({width: (categoryImageMaxPanelWidth) + 'px', display: 'block'}, "fast");
			$("#categoryImages").addClass('shadow');
		} else {
			$("#categoryImages").animate({width: categoryImageMinPanelWidth + 'px'}, "fast");
//			$(".images_visible").animate({width: (categoryImageMinPanelWidth-50) + 'px', display: 'block'}, "fast");
			$(".images_visible").animate({width: (categoryImageMinPanelWidth) + 'px', display: 'block'}, "fast");
			$("#categoryImages").removeClass('shadow');
		}
		categoryImagesSate ^= 1;
	});
	initStage();
//	loadKonvaState();
	recalcSandboxSizes();
	$("#iterations").hide();
    <% if (!(typeof sessionId !== 'undefined')) { %>
		selectFirstCategoryFromStart();
	<% } %>
	$('#inviteClientBtn').click(inviteClient);

	loadSandboxWithProgress();

	var p2psettings = loadP2PDataFromLocalStorage();
	if (p2psettings) {
		launchPeer(p2psettings.clientId, p2psettings.targetId, p2psettings.initDataChannel);
	}
  });

	function closeInviteDialog() {
		invitePopupDialog.dialog( "close" );
	}

/*
	window.onbeforeunload = function (event) {
		disconnectPeer();
		return null;
	};
*/
	let unloadProcessed = false;
	const unloadProcessor = function() {
		console.log("unloadProcessor", unloadProcessed);
		if (!unloadProcessed) {
			unloadProcessed = true;
			disconnectPeer();
			sessionStorage.setItem("activeSession", "false");
		}
	};

/*
	window.addEventListener("beforeunload", (event) => {
//		console.log("Пользователь покидает страницу (возможно, обновление).");
//		// Можно сохранить данные, отправить статистику и т.д.
		unloadProcessor();
		return null;
	});
*/

	window.addEventListener("unload", () => {
//		unloadProcessor();
		return null;
	});

	window.addEventListener("keydown", (event) => {
		processHotKeys(event);
		if ("Delete" === event.code) {
		}
	});

	document.addEventListener('dragstart', function (e) {
		if (e.target.classList.contains('category_image')) {
			e.dataTransfer.setData('text/uri-list', e.target.src);
			e.dataTransfer.setData('catId', e.target.attributes.getNamedItem('catId').value);
			e.dataTransfer.setData('imgId', e.target.attributes.getNamedItem('imgId').value);
		}
	});


	const animateBackground = (timestamp, el, direction) => {
		opacity = parseFloat(el.style.opacity);
		if (Number.isNaN(opacity)) {
			opacity = 1.0;
		}
		opacity = opacity  - .05 * direction;
		el.style.opacity = opacity;
		if (0 >= opacity) {
			direction = -direction;
		} 
		if (1 > opacity) {
			requestAnimationFrame((newtimestamp) => animateBackground(newtimestamp, el, direction));
		}
	};


	const animateElementBackgroundOpacity = (el) => {
//		el.style.animationDuration = '500ms';
//		el.style.animationDuration = '2s';
	    el.style.transition = 'opacity 1000ms linear';
		requestAnimationFrame(() => {
			el.style.opacity = '0';
		});
		setTimeout(() => {
			el.style.transition = 'opacity 1000ms linear';
			requestAnimationFrame(() => {
				el.style.opacity = '1';
			});
		}, 1000);

/*
		requestAnimationFrame(() => {
			el.style.opacity = '1';
		});
*/
	};

	const animateImageMoveToCanvasCenter = (img, targetCanvasX, targetCanvasY) => {
		const flyingImg = img.cloneNode(true);
		flyingImg.classList.add('fly-img');
		document.body.appendChild(flyingImg);

		const rect = img.getBoundingClientRect();
		const startX = rect.left + window.scrollX;
		const startY = rect.top + window.scrollY;

		flyingImg.style.left = `${startX}px`;
		flyingImg.style.top = `${startY}px`;

		const cnv = $('canvas')[0];
		const canvasRect = cnv.getBoundingClientRect();
		const endX = canvasRect.left + targetCanvasX;
		const endY = canvasRect.top + targetCanvasY;

		requestAnimationFrame(() => {
			flyingImg.style.left = `${endX}px`;
			flyingImg.style.top = `${endY}px`;
//			flyingImg.style.transform = 'scale(0.3)';
			flyingImg.style.opacity = '0.6';
		});

		setTimeout(() => {
			flyingImg.remove();
		}, 1000);
	
	};

	function showStatus(text, color) {
		const el = document.getElementById("status");
		if (!el) return;

		el.textContent = `Статус: ${text}`;
		el.style.backgroundColor = color || "gray";
	}

  </script>

</head>
<body>

<div id="status" style="padding: 8px; font-weight: bold; color: white; background: gray; width: fit-content; position: fixed">
  Статус: неизвестный
</div>

	<a href="<%=constants.MAIN_SITE_URL %>" target="sandoria_main" class="homeBtn"><img src="/images/svg/home.svg" width="16px" height="16px"/></a>
	<table width="100%" height="100%" cellpadding="0" cellspacing="0">
		<tr>
			<td id="lside" class="left_side_menu">
				<div class="logo">
					<a href="<%=constants.MAIN_SITE_URL %>" target="sandoria_main"><img src="/images/sandbox/logo.svg" width="100px" height="100px"/></a>
					<h2 style="color: #244A65">Sandoria</h2>
					<span class="slogan" style="color: #244A65">Песочная терапия онлайн</span>
				</div>
				<div class="control_panel">
					<p class="control_line" onclick="levelDown()">
						<span class="icon"><img src="/images/svg/control_back.svg"></span>
						<span class="label">На задний план</span>
					</p>

					<p class="control_line" onclick="levelUp()">
						<span class="icon"><img src="/images/svg/control_forward.svg"></span>
						<span class="label">На передний план</span>
					</p>
					<p class="control_line" onclick="copySelected()">
						<span class="icon"><img src="/images/svg/control_copy.svg"></span>
						<span class="label">Копировать</span>
					</p>
					<p class="control_line" onclick="skewSelected()">
						<span class="icon"><img src="/images/svg/control_rotate.svg"></span>
						<span class="label">Отразить</span>
					</p>
					<p class="control_line" onclick="removeSelected(null, true)" hotkey="Delete">
						<span class="icon"><img src="/images/svg/control_delete.svg"></span>
						<span class="label">Удалить</span>
					</p>
					<p class="control_line" onclick="removeAllConfirmation()">
						<span class="icon"><img src="/images/svg/control_clear_all.svg"></span>
						<span class="label">Очистить все</span>
					</p>
				</div>

			<% if (!clientMode) { %>
<!-- -->
			<div class="lbottompanel">
<!-- -->
				<div class="spaces h40">&nbsp;</div>
				<div class="inviteBtn btn1" id="inviteClientBtn">
					<img class="icon" src="/images/svg/inviteClient.svg" title="Пригласить клиента" />
					<span>
						<p><a href="#">Пригласить клиента</a></p>
					</span>
				</div>
				<div class="spaces h40">&nbsp;</div>
				<div class="inviteBtn btn2" id="takeScreenshotBtn" onclick="saveStateToImage()">
					<img class="icon" src="/images/svg/make_screenshot.svg" title="Сделать снимок" />
					<span>
						<p><a href="#">Сделать снимок</a></p>
					</span>
				</div>
<!-- -->
			</div>
<!-- -->
			<% } else { %>
				<!-- CONNECTION STATUS SECTION START -->
				<span id="connectionStatusSection">
					<div><img id='connectionStatusImg' src="/images/svg/connectionStatusDisconnected.svg" width="61" height="54" /></div>
					<div id="connectionStatusLabel" class="connectionStatusLabel">Сессия неактивна</div>
				</span>
				<!-- CONNECTION STATUS SECTION END -->
			<% }%>
			</td>
			<td id="sandbox">
				<div id="container"></div>
				<div id="containerHidden" style="display: none;"></div>
			<% if (!clientMode) { %>
				<div id="iterationsHolder">
					<span id="slideToggle" class="slideUp"></span>
<%/*

					<div id="slideToggle">
						<img src="/images/svg/slideUp.svg" />
					</div>
*/%>

					<div id="iterations"></div>
				</div>
			<% } %>
			</td>
			<td id="rside">
				<div class="rsidecontent">
					<span id="category_label"></span>
					<div id="top_categories">

					<% 
					if (categories && categories.size > 0) {
						let categoryLastIndex = categories.size - 1;
						let currntCategoryIndex = 0;
						for (let category of categories.values()) {
					%>
					<span class="topCategory" cid="<%= category.id %>" cname="<%= category.title %>" icon="<%= category.icon %>" inverticon="<%= category.invert_icon %>">
						<img data-src="<%= category.icon %>"/>
					</span>
					<div id="images_<%= category.id %>" class="images_hidden">
					<%
						let lastImageIndex = category.images.length - 1;
						for (const [imageIndex, image] of category.images.entries()) {
					%>
							<span class="imageCell">
								<img class="category_image" data-src="<%= image.image %>" title="<%= image.title %>" loading="eager" catId="<%= category.id %>" imgId="<%= image.id %>" onclick="handleImageSelect(imageSelectEvent(this.src, '<%= category.id %>', '<%= image.id %>'), true)"/>
							</span>
					<%  } %>
					</div>
				<% 
						++currntCategoryIndex;
					}
					} else { 
					%>
						<div class="no-categories">
							<p>No categories available at the moment.</p>
						</div>
					<% } %>

					</div>
					<div id="categoryImages">
						<div id="categoryImagesHolder" style="position: relative;">
							<span id="categoryImageSlider" class="slideLeft"></span>
						</div>
					</div>
				</div>
			</td>
		</td>
	</table>

<div id="progress">Загружено: <span id="progress-value">0</span>%</div>

<div id="invite-dialog">
	<div class="halign_center mtop20 mbottom20">
		<img src="/images/svg/InfoMan.svg" />
	</div>
	<div class="halign_center">
		<p class="invitepbс">Ссылка на песочницу</p>
		<p class="invitepbсsmall" id="sessionLink"></p>
		<p class="invitepb">скопирована</p>
		<div class="spaces" style="height: 20px;">&nbsp;</div>
		<p class="inviteps mauto">Отправьте ссылку клиенту для совместного использования песочницы любым удобным для Вас способом</p>
	</div>
	<div class="spaces" style="height: 32px;">&nbsp;</div>
	<div class="halign_center">
		<div class="inviteBtn btn1 mauto" onclick="closeInviteDialog();">
			<span>
				<p><a href="#">Закрыть</a></p>
			</span>
		</div>
	</div>
</div>

<div id="clearall-confirm-dialog" width="437" height="272" style="display: none">
	<div class="confirm-dialog-content">
		<div class="halign_center">
			<span class="invitepbс">Очистить</span><span class="invitepb">&nbsp;песочницу</span>
			<div class="spaces" style="height: 16px;">&nbsp;</div>
			<div class="fs18">Вы действительно хотите удалить все объекты из песочницы?</div>
		</div>
		<div class="spaces" style="height: 32px;">&nbsp;</div>
		<div class="halign_center flex_cg_31">
			<div class="flexbtn_128_56 btn2 mauto" onclick="closeClearConfirmationDialog(true);">
				<span>Да</span>
			</div>
			<div class="flexbtn_128_56 btn1 mauto" onclick="closeClearConfirmationDialog(false);">
				<span>Нет</span>
			</div>
		</div>
	</div>
</div>

<div id="dialog-form">
<div id="tabs">
  <ul>
    <li><a href="#tabs-1">Вход</a></li>
    <li><a href="#tabs-2">Регистрация</a></li>
  </ul>
  <div id="tabs-1">
    <form action="/auth" method="POST">
      <fieldset>
        <input type="text" name="email" id="email" class="text ui-widget-content ui-corner-all" placeholder="Введите почту">
        <input type="password" name="password" id="password" class="text ui-widget-content ui-corner-all" placeholder="Введите пароль">

        <!-- Allow form submission with keyboard without duplicating the dialog button -->
        <input type="submit" tabindex="-1" value="Войти в аккаунт">
      </fieldset>
    </form>
  </div>
  <div id="tabs-2">
    <form action="/register" method="POST">
      <fieldset>
        <input type="text" name="name" id="name" class="text ui-widget-content ui-corner-all" placeholder="Ваше имя">
        <input type="text" name="email" id="email" class="text ui-widget-content ui-corner-all" placeholder="Введите почту">
        <input type="password" name="password" id="password" class="text ui-widget-content ui-corner-all" placeholder="Придумйте пароль">

        <!-- Allow form submission with keyboard without duplicating the dialog button -->
        <input type="submit" tabindex="-1" value="Зарегистрироваться">
		<p>Нажимая кнопку "Зарегистрироваться", я даю свое согласие на сбор и обработку моих персональных данных в соответствии с <a href="#" target="blank">Политикой</a> и принимаю условия <a href="#" target="blank">Пользовательствого соглащения</a></p>
      </fieldset>
    </form>
  </div>
</div> 
</div>

  <div id="rotate-overlay">
    <img src="/images/svg/screen_rotate.svg" alt="Rotate device" class="icon">

    <div class="text-title">Поверните устройство</div>
    <div class="text-sub">
      Песочница работает только<br>
      в альбомной ориентации
    </div>
  </div>

</body>
</html>